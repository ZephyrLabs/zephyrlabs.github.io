<!DOCTYPE html>
    <link id="theme" rel="stylesheet" 
    type="text/css" href="../../themes/article_dark.css" />
    <link id="theme" rel="stylesheet" 
    type="text/css" href="../../themes/article.css" />

    <script>
        function theme_toggle() {
            var theme = document.getElementsByTagName('link')[0];
            if (document.getElementById("theme_button").innerText == "Dark") {
                document.getElementById("theme_button").innerText = "Light";

                if (theme.getAttribute('href') == "../../themes/article_dark.css") {
                    theme.setAttribute('href', "../../themes/article_light.css");
                }
                
            }
            else {
                document.getElementById("theme_button").innerText = "Dark";
                theme.setAttribute('href', "../../themes/article_dark.css");
            }
        }
    </script>

    <body>        
        <div class="topnav">
            <a href="../../index.html">Home</a>
            <a href="../about/index.html">About</a>
        </div>
        <div>
            <button id="theme_button" onclick="theme_toggle()">Dark</button>
        </div>
        <div>
            <h2 id="toc_1">prime bench,</h2>

            <h3 id="toc_1.1">the insights shown by this simple benchmark tool..</h3>

            <h4 id="toc_1.1.1">what is prime bench ?</h4>

            <p>prime bench is a simple benchmark tool, part of my set of programs in the crinkle bench repository I made, to see how fast a processer could calculate the number of prime numbers within a given range, 
            specificallly how good one single core from the processer could do it..</p>

            <p>this bench has been slightly conterversial to me for the way it has shown results across the table, 
            and shows to the naked eye, that there is more to a processer&#39;s performance than just simple clockspeed or architecture,</p>

            <h4 id="toc_1.1.2">how does this benchmark work ?</h4>

            <p>the source code is available on github (via) this <a href="https://github.com/ZephyrLabs/Crinkle-bench/prime_bench/">link</a></p>

            <p>let&#39;s go over more about the benchmark itself:</p>

            <p>it is a standard algorithim to check if a number is a prime number, but checking the divisibility of the number with all the numbers behind it
            it doesn&#39;t check all the numbers behind it, rather checks half of the numbers behind the number being checked from 0 to the mid way point..
            eg. to check if 97 is a prime, it rounds to the nearest half point, which is 49, and checks if 97 is divisible from 0 to 47 onwards...
            if it finds one number that is divisible, it will immediately stop checking for that number, assumes its a composite number, and move on to the next number..</p>

            <p>calculating primes is takes a logarithmic path, where increasing the limit for finding primes leads to testing exponential amount of numbers..</p>

            <p>this can be seen with the count of numbers that need to be checked with the increase in the number limit</p>

            <p>maximum count of numbers to test = (n*(n+1))/4</p>

            <pre><code>eg, the approximate number of primes to be checked from 2 to 100 = 9900/4 = 2475, and 
            the approximate number of primes to be checked from 2 to 1000 = 999000/4 = 249750
            </code></pre>

            <h4 id="toc_1.1.3">that&#39;s 100x more numbers to check for just a 10x limit increase!</h4>

            <p>last but not least.. for choice of programming language, 
            the program is made in C++ for its speed and minimal overhead,
            unlike with other languages, which may be interpreted, 
            those would take much longer and would be much more innaccurate, as it would be a test to the interpreter, not the program itself..</p>

            <h3 id="toc_1.2">time to test drive the program!</h3>

            <p>to test this program, I used my main work laptop, as well as some single board computers, and with a help of some volunteers, even tested it on the new M1 SoC from apple ! </p>

            <p>the standard search limit selected was 1 million,
            and the scores may slightly surprise you.. </p>

            <p><code>please note, all tests ran single threadded !!!</code></p>

            <p>in the <strong>x86_64</strong> systems tested..</p>

            <p>1st test, <strong>Intel i3-1005G1:</strong>
            <code>completed in 35 seconds</code></p>

            <p>2nd test, <strong>Intel i5-8300H:</strong>
            <code>completed in 44 seconds</code></p>

            <p>3rd test, <strong>AMD ryzen 5 3600:</strong>
            <code>completed in 45 seconds</code></p>

            <p>in the <strong>ARM</strong> systems tested..</p>

            <p>1st test, <strong>Allwinner A64:</strong>
            <code>completed in 120 seconds</code></p>

            <p>2nd test, <strong>Rockchip RK3399:</strong>
            <code>completed in 72 seconds</code></p>

            <p>3rd test, <strong>Amlogic A311D:</strong>
            <code>completed in 41 seconds</code></p>

            <p>4th test, <strong>Qualcomm Snapdragon 820:</strong>
            <code>completed in 22 seconds</code></p>

            <p>5th test, <strong>Apple M1:</strong>
            <code>completed in 7 seconds</code></p>

            <p>and for fun, we slightly modifed the code, to run on some <strong>Arduino</strong> compatible boards</p>

            <p>1st test, <strong>Arduino Uno:</strong> 
            <code>completed in 240 seconds</code></p>

            <p>2nd test, <strong>Espressif ESP32:</strong>
            <code>completed in 10 seconds</code></p>

            <p>the scores seem to be all over the place, and the number make no sense at first glance,</p>

            <p><strong><q>how can an i3 surpass an i5 and even a desktop class ryzen 5</q></strong> or, </p>

            <p><strong><q>how could an ESP32 do it faster than an ARM Single board computer running at nearly 10x its clock frequency?!</q></strong></p>

            <p>and the answers have some real depth to them.., 
            remember, prime bench is program made to show how fast a processer can calculate prime numbers, </p>

            <p>and to surpass this benchmark, a processer must have:
            <li> fast clock speeds</li>
            <li>an efficent architecture, the more the basic instruction set, the better, and finally</li>
            <li>plentifuls of cache and CPU/memory integrity</li></p>

            <p>and already a lot can be made from these three points,</p>

            <p>take a look at the tests conducted for the <strong>x86</strong> systems,</p>

            <p>the i3-1005G1 is part of the latest intel core processer series for mobile compute, 
            and has the shiniest bells and whistles such as AVX-512 support and SSE2 etc.
            i.e SIMD instructions for faster vector computing..</p>

            <p>when these things are utilized during compiling, the resultant program is highly optimised for performance and is able to out perform the i5 and ryzen 5 3600 of yester year..</p>

            <p>for the <strong>ARM</strong> systems,
            the M1 SoC was the brain child of Apple&#39;s silicon technology,
            and had the latest of ARM technology, such as ARMv8.6 ISA etc</p>

            <p>and has some outstanding peformance in natively compiled programs, as well as programs virtualised in Rosetta 2 translation layer..</p>

            <p>now, these things didn&#39;t really give it any significant gain in performance, rather the indirect things that helped to push to its performance, like the having plentiful of cache for ARM&#39;s out-of-order execution model etc.</p>

            <p>the Snapdragon 820, being slightly older, still had excellent performance, and still beat every <strong>x86</strong> system tested, by a very long margin..</p>

            <p>another startling thing was that the A311D and RK3399, both having cores, that are by design SUPPOSED to outperform the SD820, actually underperformed!</p>

            <p>I will cover this part in my next article, but it seems to show a flaw in the design of these chips, that seem to be very detrimental to the performance shown here..</p>

            <p>but a key eye opener, that was observed was with the ESP32 running arduino,</p>

            <h4 id="toc_1.2.1">how could a tiny microcontroller beat out 90% of all these tested systems !?</h4>

            <p>there are 2 things that contributed to this performance gain,</p>
            <li>the lightweight arithmetic part of the instruction set, and</li>
            <li>the key tweak made in the Arduino port of this program..</li>

            <p>the key tweak made was, disabling a flag and compare check in the prime checking part of the program, </p>

            <p>this seems like cheating a bit, 
            but do be reminded that these are microcontrollers, and do not have dedicated MMU (memory management units) like with the processers tested,</p>

            <p>normal processers could move the data without a problem, due to their superiority of having dedicated memory management, hence to level the playing field 
            the key part that handicapped the chip,</p>
        
            <p> was removed, unlocking its speed, and allowing it to crunch numbers faster, </p>

            <p>after all, the program is made to test the computing limits of the chip, and was not to test the cache integrity, </p>

            <p>the cache integrity, was only a key factor for the processer to shine</p>

            <p>I will do more testing to see what more can be uncovered from this amazing insight..</p>
        </div>
    </body>
</html>